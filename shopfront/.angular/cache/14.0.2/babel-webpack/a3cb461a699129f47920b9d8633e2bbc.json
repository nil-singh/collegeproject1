{"ast":null,"code":"import parseCellValue from './parseCellValue.js';\nimport { parseCellCoordinates } from './coordinates.js';\nimport { getCellValue, getCellInlineStringValue } from '../xml/xlsx.js';\nimport { getOuterXml } from '../xml/dom.js'; // Example of a `<c/>`ell element:\n//\n// <c>\n//    <f>string</f> — formula.\n//    <v>string</v> — formula pre-computed value.\n//    <is>\n//       <t>string</t> — an `inlineStr` string (rather than a \"common string\" from a dictionary).\n//       <r>\n//          <rPr>\n//            ...\n//          </rPr>\n//          <t>string</t>\n//       </r>\n//       <rPh sb=\"1\" eb=\"1\">\n//          <t>string</t>\n//       </rPh>\n//       <phoneticPr fontId=\"1\"/>\n//    </is>\n//    <extLst>\n//       <ext>\n//          <!--any element-->\n//       </ext>\n//    </extLst>\n// </c>\n//\n\nexport default function parseCell(node, sheet, xml, values, styles, properties, options) {\n  var coords = parseCellCoordinates(node.getAttribute('r'));\n  var valueElement = getCellValue(sheet, node); // For `xpath`, `value` can be `undefined` while for native `DOMParser` it's `null`.\n  // So using `value && ...` instead of `if (value !== undefined) { ... }` here\n  // for uniform compatibility with both `xpath` and native `DOMParser`.\n\n  var value = valueElement && valueElement.textContent;\n  var type;\n\n  if (node.hasAttribute('t')) {\n    type = node.getAttribute('t');\n  }\n\n  return {\n    row: coords[0],\n    column: coords[1],\n    value: parseCellValue(value, type, {\n      getInlineStringValue: function getInlineStringValue() {\n        return getCellInlineStringValue(sheet, node);\n      },\n      getInlineStringXml: function getInlineStringXml() {\n        return getOuterXml(node);\n      },\n      getStyleId: function getStyleId() {\n        return node.getAttribute('s');\n      },\n      styles: styles,\n      values: values,\n      properties: properties,\n      options: options\n    })\n  };\n}","map":{"version":3,"names":["parseCellValue","parseCellCoordinates","getCellValue","getCellInlineStringValue","getOuterXml","parseCell","node","sheet","xml","values","styles","properties","options","coords","getAttribute","valueElement","value","textContent","type","hasAttribute","row","column","getInlineStringValue","getInlineStringXml","getStyleId"],"sources":["F:/New folder/shopfront/node_modules/read-excel-file/modules/read/parseCell.js"],"sourcesContent":["import parseCellValue from './parseCellValue.js';\nimport { parseCellCoordinates } from './coordinates.js';\nimport { getCellValue, getCellInlineStringValue } from '../xml/xlsx.js';\nimport { getOuterXml } from '../xml/dom.js'; // Example of a `<c/>`ell element:\n//\n// <c>\n//    <f>string</f> — formula.\n//    <v>string</v> — formula pre-computed value.\n//    <is>\n//       <t>string</t> — an `inlineStr` string (rather than a \"common string\" from a dictionary).\n//       <r>\n//          <rPr>\n//            ...\n//          </rPr>\n//          <t>string</t>\n//       </r>\n//       <rPh sb=\"1\" eb=\"1\">\n//          <t>string</t>\n//       </rPh>\n//       <phoneticPr fontId=\"1\"/>\n//    </is>\n//    <extLst>\n//       <ext>\n//          <!--any element-->\n//       </ext>\n//    </extLst>\n// </c>\n//\n\nexport default function parseCell(node, sheet, xml, values, styles, properties, options) {\n  var coords = parseCellCoordinates(node.getAttribute('r'));\n  var valueElement = getCellValue(sheet, node); // For `xpath`, `value` can be `undefined` while for native `DOMParser` it's `null`.\n  // So using `value && ...` instead of `if (value !== undefined) { ... }` here\n  // for uniform compatibility with both `xpath` and native `DOMParser`.\n\n  var value = valueElement && valueElement.textContent;\n  var type;\n\n  if (node.hasAttribute('t')) {\n    type = node.getAttribute('t');\n  }\n\n  return {\n    row: coords[0],\n    column: coords[1],\n    value: parseCellValue(value, type, {\n      getInlineStringValue: function getInlineStringValue() {\n        return getCellInlineStringValue(sheet, node);\n      },\n      getInlineStringXml: function getInlineStringXml() {\n        return getOuterXml(node);\n      },\n      getStyleId: function getStyleId() {\n        return node.getAttribute('s');\n      },\n      styles: styles,\n      values: values,\n      properties: properties,\n      options: options\n    })\n  };\n}\n"],"mappings":"AAAA,OAAOA,cAAP,MAA2B,qBAA3B;AACA,SAASC,oBAAT,QAAqC,kBAArC;AACA,SAASC,YAAT,EAAuBC,wBAAvB,QAAuD,gBAAvD;AACA,SAASC,WAAT,QAA4B,eAA5B,C,CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAASC,SAAT,CAAmBC,IAAnB,EAAyBC,KAAzB,EAAgCC,GAAhC,EAAqCC,MAArC,EAA6CC,MAA7C,EAAqDC,UAArD,EAAiEC,OAAjE,EAA0E;EACvF,IAAIC,MAAM,GAAGZ,oBAAoB,CAACK,IAAI,CAACQ,YAAL,CAAkB,GAAlB,CAAD,CAAjC;EACA,IAAIC,YAAY,GAAGb,YAAY,CAACK,KAAD,EAAQD,IAAR,CAA/B,CAFuF,CAEzC;EAC9C;EACA;;EAEA,IAAIU,KAAK,GAAGD,YAAY,IAAIA,YAAY,CAACE,WAAzC;EACA,IAAIC,IAAJ;;EAEA,IAAIZ,IAAI,CAACa,YAAL,CAAkB,GAAlB,CAAJ,EAA4B;IAC1BD,IAAI,GAAGZ,IAAI,CAACQ,YAAL,CAAkB,GAAlB,CAAP;EACD;;EAED,OAAO;IACLM,GAAG,EAAEP,MAAM,CAAC,CAAD,CADN;IAELQ,MAAM,EAAER,MAAM,CAAC,CAAD,CAFT;IAGLG,KAAK,EAAEhB,cAAc,CAACgB,KAAD,EAAQE,IAAR,EAAc;MACjCI,oBAAoB,EAAE,SAASA,oBAAT,GAAgC;QACpD,OAAOnB,wBAAwB,CAACI,KAAD,EAAQD,IAAR,CAA/B;MACD,CAHgC;MAIjCiB,kBAAkB,EAAE,SAASA,kBAAT,GAA8B;QAChD,OAAOnB,WAAW,CAACE,IAAD,CAAlB;MACD,CANgC;MAOjCkB,UAAU,EAAE,SAASA,UAAT,GAAsB;QAChC,OAAOlB,IAAI,CAACQ,YAAL,CAAkB,GAAlB,CAAP;MACD,CATgC;MAUjCJ,MAAM,EAAEA,MAVyB;MAWjCD,MAAM,EAAEA,MAXyB;MAYjCE,UAAU,EAAEA,UAZqB;MAajCC,OAAO,EAAEA;IAbwB,CAAd;EAHhB,CAAP;AAmBD"},"metadata":{},"sourceType":"module"}